Build a Browser App: “Update-Only Email Verifier”
Goal

Create a simple web app that lets any non-technical user upload a large CSV/XLSX (multi-sheet supported), validates and safely fixes only the Email column, and then downloads:

the updated file (same format and schema as input), and

an optional “changes report” CSV.

No command line. Everything happens in the browser via a clean, single-page interface.

UX Requirements (non-technical friendly)

One-page UI with:

Drag-and-drop or “Choose file” upload.

Options panel:

Checkbox: “Use deterministic checks only (no AI)” (default ON if no API key present).

Slider: Confidence threshold (0.50–0.99; default 0.85) — only applies when AI is used.

Checkbox: “Export changes report (CSV)” (default ON).

Process button that stays disabled until a valid file is selected.

Progress indicator (percent + short status text).

Results summary cards: counts of Accepted, Fixed, Review, Suppress.

Download buttons for the updated file and (if enabled) the changes report.

Copy should be plain and reassuring. Avoid technical jargon.

Accessible design: high contrast, keyboard navigation, ARIA labels, large click targets.

Functional Requirements

Input formats

Accept .csv and .xlsx. For .xlsx, process all sheets.

Email column header can vary; match case-insensitively among:
email, email address, e-mail, work email, business email.

If no Email column on a sheet, pass it through unchanged.

Update-only policy

Keep the entire schema identical: same sheets, column order, row count, and dtypes when feasible.

Only overwrite cells in the Email column.

For rows marked review or suppress, leave the original email untouched.

Deterministic pre-pass (always on)

Normalize:

Trim whitespace; remove zero-width chars; replace smart quotes.

Strip surrounding angle brackets.

Replace fullwidth ＠ with @.

Remove internal spaces.

Lowercase domain part only; keep local part casing.

Strip trailing dot in domain.

Collapse consecutive dots in domain; in local, collapse only if the correction is obviously safe (e.g., john..doe → john.doe).

Guards:

Exactly one @; non-empty local & domain; no spaces; no leading/trailing dot; no consecutive dots (post-fix).

Fix maps:

TLD typos: .con→.com, .cmo→.com, .cim→.com, .c0m→.com.

Domain typos: gmial.com→gmail.com, gamil.com→gmail.com, outlok.com→outlook.com, yahho.com→yahoo.com, faceboook.com→facebook.com.

Flags:

role_account if local part in {info, sales, support, admin, noreply, careers, billing, accounts, contact, jobs, press, hello}.

free_mail_domain for common freemail (gmail/outlook/yahoo/icloud/proton/aol, etc.).

disposable_domain via a local list (file-based, editable).

non_ascii_domain → convert with idna (punycode) and flag.

Produce a local decision per row: accept / fix_auto / review / suppress, and a suggested normalized email.

Optional AI pass (only if enabled)

Only send the email string and boolean flags (no names, no company info).

Require JSON-only output with this exact schema:

{"input_email":"","normalized_email":"","action":"accept|fix_auto|review|suppress","confidence":0.0,"risk_reasons":[],"suggested_fix":null,"notes":""}


AI instructions:

Validate plausibility only; no network calls; never claim deliverability.

Apply the same normalization and typo logic.

Suggest at most one unambiguous correction (.con→.com, gmial→gmail, stray dot).

Choose action and set confidence in [0,1].

Routing logic (authoritative)

If action == "accept" → write normalized_email (or keep original if identical).

If action == "fix_auto" and confidence ≥ threshold (default 0.85) → write suggested_fix if present else normalized_email.

Else (review or suppress) → leave original as-is.

Log every change with reason & confidence for the report.

Outputs

Output file format matches input (CSV→CSV, XLSX→XLSX).

Optional changes_report.csv with columns:
sheet, row_index, original_email, new_email, reason, confidence.

Performance & Robustness

Handle ≥50,000 rows gracefully.

CSV: chunked read (e.g., 20k rows per chunk); write to a temporary file and then finalize.

XLSX: iterate sheets; use efficient in-memory handling with openpyxl. For very large sheets, stream rows.

Async/batched AI calls with retry/backoff and rate-limit handling.

If no API key is present or AI errors occur, automatically run deterministic-only and show a friendly banner.

Privacy & Safety

Do not send any PII other than the raw email string and boolean flags to AI.

Do not perform DNS/MX/SMTP checks. State clearly in the UI that the tool validates format and plausibility, not deliverability.

Implementation Details

Language: Python 3.11+

Core libs: pandas, openpyxl, idna, rapidfuzz, email-validator, python-dotenv.

Web stack: FastAPI + single HTML template (vanilla JS) or Streamlit (pick one and keep it simple).

If using FastAPI, include:

GET / → HTML UI (upload form, options)

POST /process → returns job id

GET /progress/{job_id} → JSON progress

GET /result/{job_id} → file downloads (updated + report)

AI adapter (optional): pluggable OpenAI/Anthropic client; JSON-mode enforced; deterministic fallback if no keys.

Config: .env for API keys and model name; config.yaml for thresholds, typo maps, and domain lists.